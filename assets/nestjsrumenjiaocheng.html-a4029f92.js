import{_ as e,o as s,c as a,e as n}from"./app-82380d9e.js";const t={},p=n(`<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>Nest 是一个用于构建高效，可扩展的 Node.js 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全支持 TypeScript（但仍然允许开发人员使用纯 JavaScript 编写代码）并结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。</p><p>在底层，Nest 使用强大的 HTTP Server 框架，如 Express（默认）和 Fastify。Nest 在这些框架之上提供了一定程度的抽象，同时也将其 API 直接暴露给开发人员。这样可以轻松使用每个平台的无数第三方模块。</p><h2 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h2><p>nest 提供了脚手架来快速创建项目。</p><p>通过下面的命令来快速的安装脚手架和创建项目：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> i <span class="token parameter variable">-g</span> @nestjs/cli <span class="token comment"># 安装脚手架</span>
nest new project-name <span class="token comment"># 创建一个项目</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.63elofbs6q00.webp" alt="image"></p><p>项目创建成功之后，就可以通过 cd 命令切换到项目目录下，然后运行项目。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> demo1 <span class="token comment"># demo1是项目的名字</span>
<span class="token function">yarn</span> run start:dev <span class="token comment"># 采用-watch的模式来运行项目</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.416aeojom160.webp" alt="image"></p><p>项目运行起来后，就可以通过<code>localhost:3000</code>在浏览器中访问项目。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4tlx5h8d00i0.webp" alt="image"></p><p>当可以在浏览器中看到<code>hello,world</code>的时候就表示你的项目已经成功运行起来了。</p><blockquote><p>项目在安装的过程中，会自动安装依赖，所以无需进入项目后再次安装依赖。</p></blockquote><h2 id="项目目录介绍" tabindex="-1"><a class="header-anchor" href="#项目目录介绍" aria-hidden="true">#</a> 项目目录介绍</h2><p>整个项目中 dist 目录是项目文件打包输出的目录，而 src 目录则是项目的源代码目录。</p><p>在 src 目录下会存在以下的几个文件：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.28cldhnxmj40.webp" alt="image"></p><p>这几个文件的作用如下：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.5wdjsebes040.webp" alt="image"></p><blockquote><p>我们这里学习先不考虑测试的问题，所以先把测试文件<code>app.controller.spec.ts</code>文件删除掉。</p></blockquote><h2 id="项目的运行机制" tabindex="-1"><a class="header-anchor" href="#项目的运行机制" aria-hidden="true">#</a> 项目的运行机制</h2><p>nest 项目和其他的前端项目相同，都是从入门文件开始执行。其中 src 目录下的 main.ts 就是入口文件。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.73hcbqtffu40.webp" alt="image"></p><p>在 main.ts 文件中，包含了一个函数 bootstrap，在这个函数中利用 NestFactory 的静态方法 create 创建了应用，并且在应用中通过 create 方法创建的应用实例监听了 3000 端口。</p><p>在 create 方法中，可以看到其中传入了一个 AppModule，这里它的作用类似于 Vue 项目中的根组件 App.vue。</p><p>所以，我们首先打开这个 AppModule 所在的文件。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.39u1jmhro2g0.webp" alt="image"></p><p>在这个文件中，我们可以看到，整个文件的最后，导出了一个 AppModule 类。虽然这是一个空的类，但是在这个类的身上却使用了 TS 中的装饰器，通过装饰器，可以给这个类添加很多不存在的内容。</p><p>首先，装饰器 Module 是 Nest 提供的，所以这里对于我们来说暂时可以不需要去管它。我们只需要把注意力放在装饰器中的 controllers 属性和 providers 的身上。一般来说，controllers 主要用来负责路由相关的内容，而 providers 则主要是服务的提供者。</p><p>下面来看一下 controllers 中的内容。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.7dhmecrhu480.webp" alt="image"></p><p>在这个文件中，我们可以发现最后同样是导出了一个类，只不过，这个类的类名叫做 AppController。</p><p>这里，首先我们需要关注到 AppController 中的构造函数，在参数的位置，注入了一个 AppService，这个 AppService 是一个服务提供者。</p><p>比如 getHello()函数在返回值中就直接调用了 appService 这个服务提供者的 getHello()方法。</p><p>刚才在上面说过，controller 中是定义访问的路由，那么也没有看到这个文件中哪个位置能设置路由啊？</p><p>其实呢，设置路由的位置在@Controller 装饰器和@Get 装饰器中。</p><p>比如默认的情况下，@Get()装饰器中什么都没有，那么访问的地址就是 localhost:3000,但是如果我们在@Get()中写入一个新的地址比如:/a，那么想要访问，url 中的地址就需要变成 localhost:3000/a。</p><p>如果在@Controller()中传入新的地址，比如/user,那么在 url 中就需要输入 localhost:3000/user/a。</p><p>最后，再来看看 service 文件，在其中可以编写提供的服务代码：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.2r3yi0o0qg80.webp" alt="image"></p><p>在这个 service 中同样导出了一个类，并且这个类中定义了一个函数<code>getHello</code>，这个函数的作用主要是给 controller 提供服务。</p><p>最后用一幅图来表示 nest 的整个服务流程：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4xmkbm2h2a40.webp" alt="image"></p><blockquote><p>在 controller 中也可以针对路由进行反馈，但是一般来讲，controller 仅仅负责路由管理，真正的服务还是要交给 services。这么做的好处除了便于维护外，还能更好的进行协作开发。</p></blockquote><h2 id="创建-service-使用新的服务提供者" tabindex="-1"><a class="header-anchor" href="#创建-service-使用新的服务提供者" aria-hidden="true">#</a> 创建 service,使用新的服务提供者</h2><p>接下来尝试创建一个新的服务，来服务路由。</p><p>创建 service 有两种方式，一种是手动创建服务，一种是通过命令自动创建服务。</p><h3 id="手动创建一个服务" tabindex="-1"><a class="header-anchor" href="#手动创建一个服务" aria-hidden="true">#</a> 手动创建一个服务</h3><p>在 src 目录下创建一个 demo1.service.ts 文件。</p><p>编写文件内容主要分成三个步骤:</p><ol><li>引入装饰器</li><li>导出一个类</li><li>使用装饰器</li></ol><p>具体代码如下：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 1. 引入装饰器</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;@nestjs/common&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 导出一个类</span>
<span class="token comment">// 3. 使用装饰器</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Demo1Service</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基本的服务创建好之后，就可以直接在导出的类中编写函数了。</p><p>例如：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Demo1Service</span> <span class="token punctuation">{</span>
  <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;这是demo1 service&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>service 服务创建好之后，想要使用，基本上可以分为下面的几个步骤：</p><ol><li>在 appModule.ts 文件中的 providers 中进行注册。</li><li>在需要使用到 service 的 ts 文件中引入。</li><li>在 constructor 中进行注册。</li></ol><p>首先，先在 appModule 文件中引入并且使用。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.43661i91i5o0.webp" alt="image"></p><p>然后在需要用到 service 的 controller 中进行引入。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1av00m6i260w.webp" alt="image"></p><blockquote><p>在 controller 中如果想要使用一个服务，首先需要先引入，然后在 constructor 中进行注册，最后方法中使用 service 中提供的方法。</p></blockquote><p>一个 service 除了在一个 controller 中使用以外，还可以在其他的 service 中使用。</p><p>使用方式和上面在 controller 中的方式相同。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.5vofw0hn95g0.webp" alt="image"></p><h3 id="自动创建服务" tabindex="-1"><a class="header-anchor" href="#自动创建服务" aria-hidden="true">#</a> 自动创建服务</h3><p>上面是通过手动创建文件的方式创建了一个 service，接下来通过命令的形式来创建一个服务。</p><p>通过下面的命令来创建服务：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nest g s 文件名 --no-spec <span class="token parameter variable">--flat</span> <span class="token comment"># --no-spec的作用是不去创建测试文件</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>比如：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.66x12twb2qo0.webp" alt="image"></p><p>通过上面的提示可以看到，命令执行完毕之后在 src 目录下创建了一个 demo2.service.ts 文件，并且更新了 app.module.ts。</p><p>两个文件内容如下：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1n2g154xzkxs.webp" alt="image"></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.3v6cvdmmazm0.webp" alt="image"></p><h2 id="动态服务提供者" tabindex="-1"><a class="header-anchor" href="#动态服务提供者" aria-hidden="true">#</a> 动态服务提供者</h2><p>如果想要根据环境变量进行服务的注册和使用，那么可以参考下面的方式实现。</p><p>比如，我们现在存在下面的两个服务：</p><p><strong>development.service.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.2m747mkjodo0.webp" alt="image"></p><p><strong>production.service.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.gwfbsvtnxvs.webp" alt="image"></p><p>假设我们的需求是想要在生产模式下使用 production.service.ts 提供服务，想要在开发模式下使用 development.service.ts 来提供服务。</p><p>此时如果想要实现需求，就需要设置环境变量。</p><h3 id="设置环境变量" tabindex="-1"><a class="header-anchor" href="#设置环境变量" aria-hidden="true">#</a> 设置环境变量</h3><p>想要实现需求，首先，我们可以在项目的根目录下创建一个.env 文件，在其中设置环境变量。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6ajzj9jrnk00.webp" alt="image"></p><h3 id="安装-dotenv-动态判断-env" tabindex="-1"><a class="header-anchor" href="#安装-dotenv-动态判断-env" aria-hidden="true">#</a> 安装 dotenv，动态判断 env</h3><p>上面我们创建了 env 文件，并且在其中设置了 mode 模式，我们如果想要拿到这个 mode 值，可以通过 dotenv 这个包，通过 dotenv,可以动态的读取 env 文件，然后将读取到的 env 文件合并到 node 环境下的全局对象 p<wbr>rocess.env 中，这样的话，我们就可以在 p<wbr>rocess.env 中动态的拿到结果，然后对其进行判断。</p><p>通过下面的命令来进行安装 dotenv:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> dotenv
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装完成后，还需要进行一项额外的配置，打开 tsconfig.json 文件，在其中配置项的最后添加上如下的配置项：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token property">&quot;esModuleInterop&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加上这个配置项的作用是可以允许我们在 import 导包的时候可以支持 export default 的导出和 import 的引入模式。</p><p>比如：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> xxx <span class="token keyword">from</span> <span class="token string">&quot;xxx&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们在 app.module.ts 中引入模块，进行相应操作：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> DotEnv <span class="token keyword">from</span> <span class="token string">&quot;dotenv&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> join <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;path&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// console.log(DotEnv);</span>
<span class="token comment">// 利用DotEnv将env文件中的内容读取，然后合并到p<wbr>rocess.env中</span>
DotEnv<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&quot;../.env&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 从p<wbr>rocess.env中读取mode</span>

<span class="token keyword">const</span> ConfigServiceMode <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">&quot;ConfigServiceMode&quot;</span><span class="token punctuation">,</span>
  useClass<span class="token operator">:</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>mode <span class="token operator">===</span> <span class="token string">&quot;development&quot;</span> <span class="token operator">?</span> DevelopmentService <span class="token operator">:</span> ProductionService<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后在 appModule 中的 providers 中进行注册即可。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.3wf998pjbu40.webp" alt="image"></p><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><p>注册成功后，可以直接在 controller 中使用。在 controller 中可以通过@Inject()装饰器来在构造函数中进行注册。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4wk5vyt66v00.webp" alt="image"></p><blockquote><p>Inject()注入的内容 service 不需要 import 引入。</p></blockquote><h2 id="动态设置服务参数" tabindex="-1"><a class="header-anchor" href="#动态设置服务参数" aria-hidden="true">#</a> 动态设置服务参数</h2><p>如果在开发中，需要动态设置一些参数，也可以参考下面的内容。</p><h3 id="创建用于测试的参数配置文件" tabindex="-1"><a class="header-anchor" href="#创建用于测试的参数配置文件" aria-hidden="true">#</a> 创建用于测试的参数配置文件</h3><p>在项目的根目录 src 下创建一个目录：config, 在 config 目录中创建两个用来记录参数的文件：</p><p><strong>dev.config.ts</strong><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.42p4t3anm0g0.webp" alt="image"></p><p><strong>prod.config.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.40i5ye5pw2o0.webp" alt="image"></p><h3 id="创建注册配置文件的-service" tabindex="-1"><a class="header-anchor" href="#创建注册配置文件的-service" aria-hidden="true">#</a> 创建注册配置文件的 service</h3><p>在 src 目录下创建一个 config.service.ts 文件。</p><p>内容如下：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1z7q29k899ds.webp" alt="image"></p><blockquote><p>需要注意的是，这里在配置 service 对象的时候，使用的是 useValue 而不是 useClass。</p></blockquote><p>最后只需要把这个服务在 app.module.ts 文件中进行注册即可。</p><h3 id="注册" tabindex="-1"><a class="header-anchor" href="#注册" aria-hidden="true">#</a> 注册</h3><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6qzk48le8jo0.webp" alt="image"></p><h2 id="使用工厂函数注册服务提供者" tabindex="-1"><a class="header-anchor" href="#使用工厂函数注册服务提供者" aria-hidden="true">#</a> 使用工厂函数注册服务提供者</h2><p>接下来使用工厂函数来注册服务的提供者，这种写法主要针对的是服务提供者的类需要参数的情况，具体可以参照下面的写法。</p><h3 id="工厂函数的使用" tabindex="-1"><a class="header-anchor" href="#工厂函数的使用" aria-hidden="true">#</a> 工厂函数的使用</h3><p>首先，我们可以在 app.module.ts 文件中的 module 装饰器的 providers 属性中进行设置：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.wqq95mmbpts.webp" alt="image"></p><p>上面的代码中通过工厂函数注册完成一个服务之后，就可以直接在 controller 中进行使用。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.5fyrkawtkpo0.webp" alt="image"></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.a7z5rtu6l6g.webp" alt="image"></p><p>访问地址：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.kv75czxkmzk.webp" alt="image"></p><h3 id="创建-db-service-函数" tabindex="-1"><a class="header-anchor" href="#创建-db-service-函数" aria-hidden="true">#</a> 创建 db.service 函数</h3><p>在测试完成工厂函数创建服务之后，再来创建一个 db.service.ts 文件，通过这个文件来实现 service 的服务。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.50sagew5eww0.webp" alt="image"></p><p>db.service.ts 这个服务，需要在构造函数中接受一个参数，该参数是一个对象，里面存储着操作数据库的基本数据。</p><h3 id="在工厂函数中实例化-dbservice" tabindex="-1"><a class="header-anchor" href="#在工厂函数中实例化-dbservice" aria-hidden="true">#</a> 在工厂函数中实例化 DbService</h3><p>接下来在工厂函数中将刚才创建的 DbService 进行实例化操作。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.koztyzs705c.webp" alt="image"></p><p>inject 字段是用来把之前注册过的对象引入进来，同时把其当作参数传递到 DbService 构造函数中。</p><blockquote><p>在 controller 中的使用和之前使用普通的工厂函数一样。</p></blockquote><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6uai4bzf0ts0.webp" alt="image"></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.3jwaif8v8c80.webp" alt="image"></p><p>访问浏览器效果如下：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6m3stjssqvc0.webp" alt="image"></p><h2 id="模块共享服务" tabindex="-1"><a class="header-anchor" href="#模块共享服务" aria-hidden="true">#</a> 模块共享服务</h2><p>在之前的代码中，我们的 app.module.ts 模块中做了非常多的事情，包括设置配置项、创建数据库连接等等。但是实际开发中我们是需要尽可能的保证模块功能唯一的。</p><p>接下来我们需要做的事就是来创建模块，然后将功能拆分。</p><blockquote><p>这里建议新创建一个空白的项目来进行测试。</p></blockquote><h3 id="通过命令创建模块" tabindex="-1"><a class="header-anchor" href="#通过命令创建模块" aria-hidden="true">#</a> 通过命令创建模块</h3><p>这里我们可以通过下面的命令来创建模块：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nest g mo 模块名 <span class="token parameter variable">-d</span> <span class="token comment"># 测试，通过该命令可以创建出哪些文件，但是这些文件并不会写入到内存中，仅仅让开发者看一下执行的结果</span>
nest g mo 模块名 <span class="token comment"># 真正创建模块</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>例如:</p><p><strong>执行 nest g mo 模块名 -d</strong>: <img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4x1z8suhwgc.webp" alt="image"></p><p><strong>执行 nest g mo 模块名</strong>: <img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1xiocgvtffa8.webp" alt="image"></p><blockquote><p>上面的第二条命令才是真正的创建模块。</p></blockquote><p>通过上面的命令创建的模块我们需要在 app.module.ts 文件中进行注册。</p><blockquote><p>这里我已经把新创建的项目中 app 前缀的文件都已经迁移到了 app 目录中，如果没有做这一步迁移而是直接创建模块的话，就会在执行上面命令的时候同时做两件事：创建模块、更新 app.module 文件。</p></blockquote><blockquote><p>这里因为并没有帮助我们更新 app.module，所以需要手动更新一下 app.module 文件。</p></blockquote><p><strong>更新 app.module.ts 文件</strong>:</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.18qhs5j6lbj4.webp" alt="image"></p><h3 id="通过命令创建-controller-和-service" tabindex="-1"><a class="header-anchor" href="#通过命令创建-controller-和-service" aria-hidden="true">#</a> 通过命令创建 controller 和 service</h3><p>上面我们通过命令创建了一个 hd 模块，但是我们要知道的是，在 nest 中仅仅凭借一个 module 模块是做不了什么事情的，还需要我们拥有对应的 controller 和 service 才可以。这时，我们就可以通过命令来给对应的模块创建 controller 和 service。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nest g s xz <span class="token comment"># 创建一个hd service</span>
nest g s xz <span class="token parameter variable">-d</span> <span class="token comment"># 测试该条命令会得到什么结果</span>
nest g s xz --no-spec <span class="token comment"># 不创建service 的测试文件</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>创建 service 的时候，如果已经存在了和 service 同名的文件夹，就会自动把 service 合并到对应的文件夹内。</p></blockquote><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.5w8x6rdgfjg0.webp" alt="image"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nest g co xz <span class="token comment"># 创建一个hd controller</span>
nest g co xz <span class="token parameter variable">-d</span> <span class="token comment"># 测试</span>
nest g co xz --no-spec <span class="token comment"># 不要当前controller的测试文件</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的命令执行完毕，我们就已经可以在 xz 目录下看到三个文件：controller、service、module。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.58oggzv3xbk0.webp" alt="image"></p><p>并且因为是通过命令创建的内容，所以 controller 和 service 已经自动的在 module 中进行了注册。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.g3ywpabzuxs.webp" alt="image"></p><p>这时可以做一个测试，来试一下代码是否好用，可以在 xz 的 controller 中，编写一个路由，看看是否能够正常使用。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.34ydsjplc9m0.webp" alt="image"></p><p>打开浏览器，输入地址: <code>localhost:3000/xz/list1</code>，查看效果： <img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1ce1i8sxy70g.webp" alt="image"></p><h2 id="在一个模块中引入另外一个模块" tabindex="-1"><a class="header-anchor" href="#在一个模块中引入另外一个模块" aria-hidden="true">#</a> 在一个模块中引入另外一个模块</h2><p>如果项目中存在多个模块，我们如果想要在一个模块中使用另外一个模块，那么需要做到两件事，第一是在被引用的模块中设置 exports，将服务暴露出去，第二是在使用其他模块的模块中的 module 中设置 imports 来引入。</p><p><strong>具体的使用可以参考下面的代码：</strong></p><p>首先，我们为了测试，先来创建一个 test 模块：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nest g mo <span class="token builtin class-name">test</span> <span class="token comment"># 创建一个test模块</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.51yj4tota0s0.webp" alt="image"></p><p>再来给 test 模块创建一个 service 服务。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nest g s <span class="token builtin class-name">test</span> --no-spec
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4vzl1m4v9le0.webp" alt="image"></p><p>接下来我们在 test 服务中创建一个用于测试的方法，并且把 test 的服务暴露出去。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.48m7jq24z9a0.webp" alt="image"></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.331y81sfx5c0.webp" alt="image"></p><p>接下来再在 hd 模块中引用 xz 模块。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.r568tgb0rrk.webp" alt="image"></p><p>引入完成后，就可以在 xz 的 controller 中使用 test 的 service 服务。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.197bxcov4t7k.webp" alt="image"></p><p>浏览器中访问 localhost:3000/xz/test,访问内容。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.2895b5yocnms.webp" alt="image"></p><h3 id="使用其他模块中的值" tabindex="-1"><a class="header-anchor" href="#使用其他模块中的值" aria-hidden="true">#</a> 使用其他模块中的值</h3><p>如果想要使用其他模块中的值，整体的写法和上面类似，需要先在被引入的模块中注册并且导出，才能在其他模块中使用。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4xuxmer8cr80.webp" alt="image"></p><p>导出之后就可以直接在其他的 controller 中使用。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.7lh1e1pwpeg0.webp" alt="image"></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6ywpkwxnlr00.webp" alt="image"></p><h2 id="异步提供服务" tabindex="-1"><a class="header-anchor" href="#异步提供服务" aria-hidden="true">#</a> 异步提供服务</h2><p>nestjs 允许我们采用异步的形式来提供服务。如果有这方面的需求，可以参考下面的代码：</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.14ua4fugyh6o.webp" alt="image"></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.53i9fpslvac0.webp" alt="image"></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1fnic75amj9c.webp" alt="image"></p><blockquote><p>需要注意，编写完异步的服务代码之后，建议重新启动一下服务。可以在终端中看到异步服务注册等待的时间。</p></blockquote><h2 id="动态加载参数" tabindex="-1"><a class="header-anchor" href="#动态加载参数" aria-hidden="true">#</a> 动态加载参数</h2><p>在之前的讲解中，我们在项目中引入的配置项都是使用固定的地址，如果在开发中，可能面临的是动态的配置项参数加载。所以这一小节我们讲解的是如何在 nest 项目中动态加载参数。</p><h3 id="创建测试配置项" tabindex="-1"><a class="header-anchor" href="#创建测试配置项" aria-hidden="true">#</a> 创建测试配置项</h3><p>首先，在项目的根目录下，创建一个目录 configure，在这个目录中我们创建几个 js 文件，在这些 js 文件中设置一下用来测试的参数。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.3n2wjpfhbl80.webp" alt="image"></p><p>用来测试的代码内容如下：</p><p><strong>app.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.16xb6riqzarg.webp" alt="image"></p><p><strong>database.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.3y6ki20as180.webp" alt="image"></p><p><strong>upload.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.mnvs8xo0id.webp" alt="image"></p><h3 id="创建-config-模块" tabindex="-1"><a class="header-anchor" href="#创建-config-模块" aria-hidden="true">#</a> 创建 config 模块</h3><p>在项目的根目录下创建 config 目录，在其中分别创建 config.module.ts、config.service.ts 文件。</p><p><strong>config.module.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.31k39qhduga0.webp" alt="image"></p><p><strong>config.service.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.2jvirahremi0.webp" alt="image"></p><p>模块创建好之后，在 app.module.ts 文件中引入。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4f23bqpguo40.webp" alt="image"></p><h3 id="测试-config-模块" tabindex="-1"><a class="header-anchor" href="#测试-config-模块" aria-hidden="true">#</a> 测试 config 模块</h3><p>引入完成后，先在 config.service.ts 文件中创建一个 test 方法，用来测试是否模块引入成功。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6iznei1gypc0.webp" alt="image"></p><p>接下来再在 app.controller.ts 文件中创建一个方法用来进行测试。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6da95ec2a9w0.webp" alt="image"></p><p>接下来在浏览器输入 http://localhost:3000/test-config 访问。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1v2ugxgjjwtc.webp" alt="image"></p><h3 id="读取配置文件" tabindex="-1"><a class="header-anchor" href="#读取配置文件" aria-hidden="true">#</a> 读取配置文件</h3><p>接下来在 config.service.ts 文件中编写读取配置项的代码。</p><p>这里我们利用 constructor 函数的特殊性，将读取的代码放在 config.service.ts 中的 constructor 函数中。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.416dyakbk6g0.webp" alt="image"></p><p>在上面的代码中，@Optional() 表示的是 config 参数是一个形参，而不是一个注入的内容。同时，当使用 config.service.ts 导出的类时，需要注入 CONFIG_OPTIONS 服务，这个服务本身是一个对象，其中包括 path 属性，我们将这个服务的注册放在 config.module.ts 中。</p><h3 id="config-options-注册" tabindex="-1"><a class="header-anchor" href="#config-options-注册" aria-hidden="true">#</a> CONFIG_OPTIONS 注册</h3><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.4yyild9i8340.webp" alt="image"></p><blockquote><p>其中 DynamicModule 是 nest 提供的一个 Interface，其中包括了 global、module 等属性的约束。</p></blockquote><p>上面的代码，我们在 ConfigModule 中创建了一个静态方法 forRoot,调用这个静态方法可以获取一个动态的全局的模块，同时，调用这个方法的时候，需要传入一个 options 对象，其中包括 path 属性，该属性中保存的是一个配置项的地址。</p><h3 id="在-app-module-中进行注册调用" tabindex="-1"><a class="header-anchor" href="#在-app-module-中进行注册调用" aria-hidden="true">#</a> 在 app.module 中进行注册调用</h3><p>定义好静态方法之后，我们接下来在 app.module.ts 文件中修改一下 config 模块的调用方式，可以在 imports 中直接调用静态方法 forRoot,并且同时传入配置项的地址。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.5q5n4qm5qcg0.webp" alt="image"></p><h3 id="创建获取参数的方法" tabindex="-1"><a class="header-anchor" href="#创建获取参数的方法" aria-hidden="true">#</a> 创建获取参数的方法</h3><p>上面的配置成功之后，我们最后再在 config.service 中创建一个 get 方法，通过这个 get 方法来配置项中的参数。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.7jh5r80o7is0.webp" alt="image"></p><h3 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h3><p>创建一个 article 模块用来测试，在 src 目录下创建一个 article 目录，在其中分别创建 article.controller.ts 和 article.module.ts 文件。</p><p><strong>article.module.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.1ni3n14tzydc.webp" alt="image"></p><p><strong>article.controller.ts</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6oy3rnwvsus0.webp" alt="image"></p><p>最后别忘了在 app.module.ts 中进行引入。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.6byp22yuwc00.webp" alt="image"></p><p>打开浏览器，输入 localhost:3000/article/name，如果能够正确看到结果，则表示功能测试成功。</p><p><img src="https://jsd.cdn.zzko.cn/gh/fylc21/image_hosting@master/image.vy9u1ypkz4g.webp" alt="image"></p>`,256),i=[p];function c(o,r){return s(),a("div",null,i)}const d=e(t,[["render",c],["__file","nestjsrumenjiaocheng.html.vue"]]);export{d as default};
